#!/bin/bash
# 2022-02-13 removed the branch/version stuff
# this will start a new shell that has an environment appropriate for the repo
#set -x

if [ -z "$1" ]; then
   echo "no repo specified"
   exit 1
fi
repo="$1"

if [ -z "$2" ]; then
   repo_path="$repo"
else
   repo_path="$2"
fi

# makes an init file for bash. 
# Variables from the environment will not expand within this heredoc because of the quotes around the EOF.  (Yes, that is
# a thing.)
# moved this to the .bashrc:
#      export PS1='\n$(/usr/local/bin/Z) [$(echo "$REPO")]\n\u@\h§\w§\n> '
read -r -d '' InitFile <<-"EOF"
     export HOME=$(/usr/local/bin/home)
     . $(/usr/local/bin/home)/.bashrc
     export HOME=$(/usr/local/bin/home)
     export SHELL=/bin/bash
     export USERNAME=$(/usr/local/bin/user)
     export REPOS="$HOME/repos"
     export REPO_HOME="$REPOS/$REPO_PATH"
     export RESOURCES="$REPOS/resources"
     export TMP="$RESOURCES/temporary"
     if [ ! -d "$TMP" ]; then 
       mkdir "$TMP"
     fi
     cd "$REPO_HOME"
     INITF="$REPO_HOME/executable/ch_repo_initialize"
     if [ -f "$INITF" ]; then
       . "$INITF"
     fi
     echo $PATH
EOF

# exec -c and env -i, where INSIDE_EMACS is set in the calling shell and is also set in
# the init script of the newly launched shell, does not work.  In both cases emacs stops
# tracking directory changes in the newly launched shell.  Emacs will continue to track
# directory changes if we call bash directly, or if we use env -i with INSIDE_EMACS defined
# as a parameter.
env --ignore-environment \
    INSIDE_EMACS="$INSIDE_EMACS" \
    REPO="$repo"\
    REPO_PATH="$repo_path"\
    HOSTNAME="$HOSTNAME" \
    LOGNAME="$LOGNAME" \
    DISPLAY="$DISPLAY" \
    LANG="$LANG"\
    TERM="$TERM" \
    TERMCAP="$TERMCAP" \
    EDITOR="$EDITOR" \
    PATH="/usr/local/bin:/usr/bin:/bin" \
    /bin/bash --init-file <(echo "$InitFile")

#set +x
