#!/bin/bash
# 2022-02-13 removed the branch/version stuff
# this will start a new shell that has an environment appropriate for the project
# set -x

if [ -z "$1" ]; then
   echo "no project specified"
   exit 1
fi
project="$1"

if [ -z "$2" ]; then
   project_path="$project"
else
   project_path="$2"
fi


# makes an init file for bash. Variables from the environment of 'start' will not expand
# within this heredoc because of the quotes around the EOF.  Yes, that is a thing.
# cat comes from the file system, might be better to use read
# InitFile=$(cat <<-"EOF"
read -r -d '' InitFile <<-"EOF"
     . $(/usr/local/bin/home)/.bashrc
     export SHELL=/bin/bash
     export USERNAME=$(/usr/local/bin/user)
     export HOME=$(/usr/local/bin/home)
     export REPOS="$HOME"/repos
     export RESOURCES="$REPOS"/resources
     export PROJECT_HOME="$REPOS"/"$PROJECT_PATH"
     export TMP="$RESOURCES/tmp"
     export PS1='\n$(/usr/local/bin/Z) [$(echo "$PROJECT")]\n\u@\h§\w§\n> '
     if [ ! -d "$TMP" ]; then 
       mkdir "$TMP"
     fi
     cd "$PROJECT_HOME"
     INITF="$RESOURCES/bin/$PROJECT.sh"
     if [ -f "$INITF" ]; then
       . "$INITF"
     fi
     echo $PATH
EOF

# exec -c and env -i, where INSIDE_EMACS is set in the calling shell and is also set in
# the init script of the newly launched shell, does not work.  In both cases emacs stops
# tracking directory changes in the newly launched shell.  Emacs will continue to track
# directory changes if we call bash directly, or if we use env -i with INSIDE_EMACS defined
# as a parameter.
env -i \
    INSIDE_EMACS="$INSIDE_EMACS" \
    PROJECT="$project"\
    PROJECT_PATH="$project_path"\
    HOSTNAME="$HOSTNAME" \
    LOGNAME="$LOGNAME" \
    DISPLAY="$DISPLAY" \
    LANG="$LANG"\
    TERM="$TERM" \
    TERMCAP="$TERMCAP" \
    EDITOR="$EDITOR" \
    PATH="/usr/local/bin:/usr/bin:/bin" \
    /bin/bash --init-file <(echo "$InitFile")

#set +x
